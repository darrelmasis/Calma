@use '../config/borders' as borders;
@use '../mixins/borders' as borders_mixins;
@use '../config/colors_map' as c;
@use '../config/colors' as pallette;
@use '../config/breakpoints' as bp;
@use '../mixins/mediaqueries' as mq;
@use 'sass:map';

$borders-directions: top, right, bottom, left, all, none;
$borders-radius-corners:
  top-left, top-right, bottom-left, bottom-right, top, bottom, left, right,
  pill, circle, all;

$border-style-colors: (
  'primary': c.$primary,
  'danger': c.$danger,
  'warning': c.$warning,
  'success': c.$success,
  'info': c.$info,
  'light': c.$light,
  'dark': c.$dark,
  'base-style': c.$border-color,
  'white': #ffffff
);

$border-semantic-palettes: (
  'primary': pallette.$golds,
  'danger': pallette.$reds,
  'warning': pallette.$yellows,
  'success': pallette.$greens,
  'info': pallette.$blues,
  'purple': pallette.$purples,
  'wine': pallette.$wines,
  'light': pallette.$lights,
  'dark': pallette.$darks,
  'neutral': pallette.$neutrals
);

$border-style: borders.$border-width borders.$border-style var(--border-color);

// Generador de clases border-n
// Generador responsive de border-width
@each $step, $size in borders.$border-widths-steps {
  // Clase base (mobile first)
  .border-#{$step} {
    border-width: $size !important;
  }

  // Clases responsive por breakpoint
  @each $bp-name, $bp-size in bp.$breakpoints {
    @include mq.screen(min, $bp-name) {
      .border-#{$bp-name}-#{$step} {
        border-width: $size !important;
      }
    }
  }
}

// -------------------------------
// Bordes base-style (legacy por defecto)
// -------------------------------
@each $direction in $borders-directions {
  @if $direction == 'all' {
    .border {
      @include borders_mixins.border(
        'all',
        borders.$border-width borders.$border-style
          map.get($border-style-colors, 'base-style')
      );
    }
  } @else if $direction == 'none' {
    .border-none {
      border: none;
    }
  } @else {
    .border-#{$direction} {
      @include borders_mixins.border(
        $direction,
        borders.$border-width borders.$border-style
          map.get($border-style-colors, 'base-style')
      );
    }
  }
}

// -------------------------------
// Bordes con colores adicionales
// -------------------------------
@each $direction in $borders-directions {
  @each $color-name, $color-value in $border-style-colors {
    @if $color-name != 'base-style' and $direction != 'none' {
      // Base mobile
      @if $direction == 'all' {
        .border-#{$color-name} {
          @include borders_mixins.border(
            'all',
            borders.$border-width borders.$border-style $color-value
          );
        }
      } @else {
        .border-#{$direction}-#{$color-name} {
          @include borders_mixins.border(
            $direction,
            borders.$border-width borders.$border-style $color-value
          );
        }
      }

      // Responsive
      @each $bp-name, $bp-size in bp.$breakpoints {
        @include mq.screen(min, $bp-name) {
          @if $direction == 'all' {
            .border-#{$bp-name}-#{$color-name} {
              @include borders_mixins.border(
                'all',
                borders.$border-width borders.$border-style $color-value
              );
            }
          } @else {
            .border-#{$direction}-#{$bp-name}-#{$color-name} {
              @include borders_mixins.border(
                $direction,
                borders.$border-width borders.$border-style $color-value
              );
            }
          }
        }
      }
    }
  }
}

// -------------------------------
// Bordes con paletas semánticas (500 por defecto)
// -------------------------------

// -------------------------------
// Bordes semánticos con variantes de tono: .border-primary-100, .border-danger-500, etc.
// -------------------------------
@each $semantic-name, $palette in $border-semantic-palettes {
  @each $shade, $color in $palette {
    // Opcional: omitir '0' si no quieres el blanco (ej. border-primary-0)
    // @if $shade != '0' {

    @each $direction in $borders-directions {
      @if $direction != 'none' {
        // Clase base (mobile-first)
        @if $direction == 'all' {
          .border-#{$semantic-name}-#{$shade} {
            @include borders_mixins.border(
              'all',
              borders.$border-width borders.$border-style $color
            );
          }
        } @else {
          .border-#{$direction}-#{$semantic-name}-#{$shade} {
            @include borders_mixins.border(
              $direction,
              borders.$border-width borders.$border-style $color
            );
          }
        }

        // Responsive
        @each $bp-name, $bp-size in bp.$breakpoints {
          @include mq.screen(min, $bp-name) {
            @if $direction == 'all' {
              .border-#{$bp-name}-#{$semantic-name}-#{$shade} {
                @include borders_mixins.border(
                  'all',
                  borders.$border-width borders.$border-style $color
                );
              }
            } @else {
              .border-#{$direction}-#{$bp-name}-#{$semantic-name}-#{$shade} {
                @include borders_mixins.border(
                  $direction,
                  borders.$border-width borders.$border-style $color
                );
              }
            }
          }
        }
      }
    }
    // }
  }
}

// Bordes redondeados
@each $corner in $borders-radius-corners {
  @each $size-name, $size-value in borders.$border-radius-steps {
    // Soporte legacy para .rounded (solo cuando corner = all y size = md)
    @if $corner == 'all' and $size-name == 'md' {
      .rounded {
        @include borders_mixins.border-radius('all', $size-value);
      }
    }

    // Clases nuevas escalables
    @if $corner == 'all' {
      .rounded-all-#{$size-name} {
        @include borders_mixins.border-radius('all', $size-value);
      }
    } @else if $corner == 'pill' {
      .rounded-#{$corner}-#{$size-name} {
        @include borders_mixins.border-radius('pill', $size-value * 3);
      }
    } @else if $corner == 'circle' {
      .rounded-#{$corner}-#{$size-name} {
        @include borders_mixins.border-radius('circle', 50%);
      }
    } @else {
      .rounded-#{$corner}-#{$size-name} {
        @include borders_mixins.border-radius($corner, $size-value);
      }
    }
  }
}
